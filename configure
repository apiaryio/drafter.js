#!/usr/bin/env python
import sys

if sys.version_info[0] != 2:
    # Since various Linux distros and OS X doesn't properly follow PEP 394,
    # We've set the shebang line to `python` and erroring when it isn't
    # Python 2.
    print(
        '{} requires Python 2, please install Python 2 and re-run this script.'.format(sys.argv[0]))
    print('You may be able to do this with `python2 configure`.')
    sys.exit()

import optparse
import os
import pprint
import re
import shlex
import subprocess
import platform
from shutil import copyfile


root_dir = os.path.dirname(__file__)
build_dir = './build'
CC = os.environ.get('CC', 'cc')

# Parse options
parser = optparse.OptionParser()
parser.add_option("--debug",
                  action="store_true",
                  dest="debug",
                  help="Also build the debug build.")

(options, args) = parser.parse_args()


def write(filename, data):
    filename = os.path.join(root_dir, filename)
    print("creating " + filename)
    f = open(filename, 'w+')
    f.write(data)


def cc_macros():
    """Checks predefined macros using the CC command."""

    try:
        p = subprocess.Popen(shlex.split(CC) + ['-dM', '-E', '-'],
                             stdin=subprocess.PIPE,
                             stdout=subprocess.PIPE,
                             stderr=subprocess.PIPE)
    except OSError:
        print('''Configure error: No acceptable C compiler found!

        Please make sure you have a C compiler installed on your system and/or
        consider adjusting the CC environment variable if you installed
        it in a non-standard prefix.
        ''')
        sys.exit()

    p.stdin.write('\n')
    out = p.communicate()[0]

    out = str(out).split('\n')

    k = {}
    for line in out:
        lst = shlex.split(line)
        if len(lst) > 2:
            key = lst[1]
            val = lst[2]
            k[key] = val
    return k


def host_arch_cc():
    """Host architecture check using the CC command."""

    k = cc_macros()

    matchup = {
        '__x86_64__': 'x64',
        '__i386__': 'ia32',
        '__arm__': 'arm',
    }

    rtn = 'ia32'  # default

    for i in matchup:
        if i in k and k[i] != '0':
            rtn = matchup[i]
            break

    return rtn


def host_arch_win():
    """Host architecture check using environ vars (better way to do this?)"""

    arch = os.environ.get('PROCESSOR_ARCHITECTURE', 'x86')

    matchup = {
        'AMD64': 'x64',
        'x86': 'ia32',
        'arm': 'arm',
    }

    return matchup.get(arch, 'ia32')


def configure_drafterjs(o):
    # Build configuration
    o['default_configuration'] = 'Debug' if options.debug else 'Release'

    # Architecture
    host_arch = host_arch_cc()
    target_arch = host_arch
    o['variables']['host_arch'] = host_arch
    o['variables']['target_arch'] = target_arch
    o['variables']['libdrafter_type'] = 'static_library'

#
# config.gypi
#
output = {
    'variables': {'python': sys.executable},
    'include_dirs': [],
    'libraries': [],
    'defines': [],
    'cflags': [],
}

configure_drafterjs(output)

# variables should be a root level element,
# move everything else to target_defaults
variables = output['variables']
del output['variables']
output = {
    'variables': variables,
    'target_defaults': output
}
write('config.gypi', "# Do not edit. Generated by the configure script.\n" +
      pprint.pformat(output, indent=2) + "\n")

if os.path.isfile('drafterjs.gyp'):
    os.remove('drafterjs.gyp')

copyfile('drafterjs.gypi', 'drafterjs.gyp')

gyp_args = ['--generator-output', build_dir, '--depth', '.', '-f', 'make']

options_fn = os.path.join(os.path.abspath(root_dir), 'config.gypi')

if os.path.exists(options_fn):
    gyp_args.extend(['-I', options_fn])

subprocess.call(
    [sys.executable, 'ext/protagonist/drafter/tools/gyp/gyp_main.py'] + gyp_args)

# All done
print("All OK.")
